## 知识点14  修饰符

**【扩展 14-1】讲一下iOS属性修饰符atomic的实现机制(内部是怎么实现的)；为什么不能保证绝对的线程安全（最好可以结合场景来说）？**

atomic表示原子操作，系统会为setter方法加锁，具体适用@synchronized(self){//code},保证读写互斥，即读取的时候不能修改值，修改值的时候不能读取，以保证线程安全。

使用atomic并不能保证绝对的线程安全。因为atomic只能保证对属性的读写是原子性的，但是仍然可能出现线程错误。比如：当线程A进行写操作时，其他线程的读或者写操作会因为该操作而等待，当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获取了在B线程中的值，这就破坏了线程安全。如果有线程C在A线程读操作之前release了该属性，那么将会导致程序崩溃。所以仅仅使用atomic并不能保证线程安全，只是保证了属性getter和setter方法的线程安全。

**【扩展 14-2】成员变量、实例变量和属性的区别和联系？**

* （1）成员变量：成员变量是定义在{}中的变量，如果成员变量的数据类型是一个类，则称该变量为实例变量(实例变量是针对类而言的)，所以实例变量是成员变量的一种特殊情况。成员变量不会生成set、get方法，所以成员变量无法被外界访问（只用于类内部），这个也就是所谓的类私有变量。

* （2）属性：使用@property声明的变量是属性，属性可以被外界访问。例如：@property (nonatomic, strong) UIButton *myButton;编译器会自动地生成一个实例变量"_myButton"，同时会生成myButton属性的getter/setter方法。在.m文件中可以直接使用实例变量_myButton，也可以通过属性self.myButton，这里的self.myButton其实是调用myButton属性的getter/setter方法。这与C++中的点方法的使用是有区别的，C++中的点方法可以直接访问成员变量。声明属性myButton后，如果.m文件中写了@synthesize myButton;那么自动生成的实例变量为myButton而不是_myButton。@synthesize的作用是生成与属性对应的实例变量，并让编译器自动生成setter和getter方法。

【注意】类与分类(Category)中添加的属性要区分开来，因为类别中只能添加方法，不能添加实例变量。即使在类别中添加了属性，也不会自动生成带下划线的实例变量，这里其实只是添加的getter与setter方法的声明，并没有getter和setter方法的实现。此外类扩展（匿名类别）是可以添加实例变量的。

【使用建议】:(1)如果只是单纯的private变量，最好声明在implementation里；（2）如果是类的public属性，就用@property写在.h文件里；（3）如果自己内部需要setter和getter来实现一些功能，就在.m文件里用property来声明。

**【扩展 14-3】被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？**

[参考链接](https://www.jianshu.com/p/10c0f49f4755)

**【扩展 14-4】实现 isEqual 和 hash 方法时要注意什么？**

**【扩展 14-5】property 的常用修饰词有哪些？weak 和 assign 的区别？weak 的实现原理是什么？**


## 知识点15  UI视图

**【扩展 15-1】哪些场景可以触发离屏渲染？（知道多少说多少）**

**【扩展 15-2】说说你对 OC 中 load 方法和 initialize 方法的异同。——主要说一下执行时间，各自用途，没实现子类的方法会不会调用父类的？**

**【扩展 15-3】UIView 生命周期**

* alloc：创建对象，分配空间
* init(initWithNibName)：初始化对象，初始化数据
* loadView：在视图控制器创建view属性时调用此方法
* viewDidLoad：加载view
* viewWillAppear：视图即将出现
* viewDidAppear：视图已经出现
* viewWillDisappear：视图即将消失
* viewDidDisappear：视图已经消失
* dealloc：视图被销毁
* didReceiveMemoryWarning：接收到内存警告时会被调用




**【扩展 15-4】如果页面 A 跳转到 页面 B，A 的 viewDidDisappear 方法和 B 的 viewDidAppear 方法哪个先调用？**

A页面跳转到B页面有2个方法,push和present。

**push**：先执行A页面的viewWillDisappear和viewDidDisappear,然后执行B页面的viewWillAppear和viewDidAppear.
**present**：先执行A页面的viewWillDisappear,随后执行B页面的viewWillAppear和viewDidAppear,最后执行A页面的viewDidDisappear.

**【扩展 15-5】细致地讲一下事件传递流程**

**事件传递流程**如下：

事件的传递是自上到下的顺序，即 UIApplication->window->处理该触摸事件最合适的 view。

当点击屏幕时会产生一个触摸事件，消息循环(runloop)会接收到该触摸事件放到消息队列中，接下来UIApplication会从消息队列中取出触摸事件并将其分发下去。首先传给UIWindow，UIWindow会使用hitTest:withEvent:方法查找到此次触摸事件初始点所在的视图，找到这个视图之后他就会调用视图的touchesBegan:withEvent:方法来处理事件。

[iOS事件传递与响应机制](https://juejin.im/entry/58451fff61ff4b006c36eba6)

[iOS UI事件传递与响应者链](https://www.jianshu.com/p/1a4570895df5)


**【扩展 15-6】谈一下对三种布局方式 frame、Auto Layout 以及 UIStackView的理解**

[iOS9 UIStackView 简介](https://swift.gg/2016/03/31/ios9-uistackview-guide-swift/)



## 知识点16  计算机网络及网络安全

**【扩展 16-1】App网络层有哪些优化策略？**

* (1)优化DNS解析和缓存

APP内置Server IP列表，该列表可以在App启动服务中下发更新。App启动后的首次网络服务会从Server IP列表中取一个IP地址进行TCP连接，同时DNS解析会并行进行，DNS成功后，会返回最适合用户网络的Server IP，那么这个Server IP会被加入到Server IP列表中被优先使用。

Server IP列表有权重机制的，DNS解析返回的IP很明显具有最高的权重，每次从Server IP列表中取IP会取权重最高的IP。列表中IP权重也是动态更新的，根据连接或者服务的成功失败来动态调整，这样即使DNS解析失败，用户在使用一段时间后也会选取到适合的Server IP。

* (2)网络质量检测（根据网络质量来改变策略）

根据用户是在2G/3G/4G/Wi-Fi的网络环境来设置不同的超时参数，以及网络服务的并发数量。比如在环境比较差的情况下:

✅将并发数设置为一个，改成串行；

✅动态设置超时时间；

✅throttle 进行节流。AFNetworking中的throttle方法

```
- (void)throttleBandwidthWithPacketSize:(NSUInteger)numberOfBytes 
```

✅管道化连接。如果服务器不支持管线化的话，那么响应就会乱序。所以服务器要支持。 AFNetworking中通过HTTPShouldUsePipelining属性来设置，默认为NO。

* (3)减少数据传输量：选择合适的数据格式进行传输，比如使用Protocol Buffer数等，使用WebP图片格式。
* (4)提供网络服务重发机制：当第一次网络请求失败的时候，自动尝试再次重发
* (5)使用HTTP缓存。

[iOS网络层详解和优化](http://www.cocoachina.com/articles/22608)

**【扩展 16-2】TCP为什么要三次握手，四次挥手？三次挥手不行吗？**

**TCP三次握手的原因**：

假如现在客户端想向服务端进行握手，它发送了第一个连接的请求报文，但是由于网络信号差或者服务器负载过多，这个请求没有立即到达服务端，而是在某个网络节点中长时间的滞留了，以至于滞留到客户端连接释放以后的某个时间点才到达服务端，那么这就是一个失效的报文，但是服务端接收到这个失效的请求报文后，就误认为客户端又发了一次连接请求，服务端就会想向客户端发出确认的报文，表示同意建立连接。
假如不采用三次握手，那么只要服务端发出确认，表示新的建立就连接了。但是现在客户端并没有发出建立连接的请求，其实这个请求是失效的请求，一切都是服务端在自相情愿，因此客户端是不会理睬服务端的确认信息，也不会向服务端发送确认的请求，但是服务器却认为新的连接已经建立起来了，并一直等待客户端发来数据，这样的情况下，服务端的很多资源就没白白浪费掉了。
采用三次握手的办法就是为了防止上述这种情况的发生，比如就在刚才的情况下，客户端不会向服务端发出确认的请求，服务端会因为收不到确认的报文，就知道客户端并没有要建立连接，那么服务端也就不会去建立连接，这就是三次握手的作用。

**TCP四次挥手的原因**：

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，在客户端想要断开连接时，客户端向服务端发送FIN报文，只是表示客户端已经没有数据要发送了，但是这个时候客户端还是可以接收来自服务端的数据。

当服务端接收到FIN报文，并返回ACK报文，表示服务端已经知道了客户端要断开连接，客户端已经没有数据要发送了，但是这个时候服务端可能依然有数据要传输给客户端。当服务端的数据传输完之后，服务端会发送FIN报文给客户端，表示服务端也没有数据要传输了，服务端同意关闭连接，之后，客户端收到FIN报文，立即发送给客户端一个ACK报文，确定关闭连接。在之后，客户端和服务端彼此就愉快的断开了这次的TCP连接。

为什么服务端的ACK报文和FIN报文都是分开发送的，但是在三次握手的时候却是ACK报文和SYN报文是一起发送的，因为在三次握手的过程中，当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是在关闭连接时，当服务端接收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，你发的FIN报文我收到了，只有等到服务端所有的数据都发送完了，才能发送FIN报文，因此ACK报文和FIN报文不能一起发送。所以断开连接的时候才需要四次挥手来完成。

三次挥手不行。因为当服务端接收到FIN报文，并返回ACK报文，仅表示服务端已经知道了客户端要断开连接，客户端已经没有数据要发送了，但是这个时候服务端可能依然有数据要传输给客户端。需要将这种特殊情况考虑进去。

**【扩展 16-3】对称加密和非对称加密的区别？分别有哪些算法来实现这两种加密？**

**对称加密**又称**公开密钥加密**，加密和解密都会用到同一个密钥，加解密速度快。由于密钥需要在网络中传输，如果密钥被攻击者获得，此时加密就失去了意义。所以安全性不高。常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。

**非对称加密**又称**共享密钥加密**，使用一对非对称的密钥，一把叫做私钥，另一把叫做公钥；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。加解密速度慢，但安全性更高。常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、ECC(椭圆曲线加密算法）。

**【扩展 16-4】HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么？**

HTTPS=HTTP+SSL/TLS，在HTTP的基础上又加了一层安全加密处理。HTTPS握手流程可细分为8步：

* 1）客户端向服务器端发起HTTPS请求。
* 2）服务器端接受请求。此时服务器端会生成一对密钥，即公钥和私钥，用来进行非对称加密使用。服务器端保存私钥，公钥可以发送给任何人。
* 3）服务器端将自己的公钥和数字证书发送给客户端。
* 4）客户端收到服务器端返回的数字证书后，会对数字证书的合法性进行校验。如何数字证书合法，客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称为客户端密钥（Client key）。然后用服务器端返回的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了。
* 5）客户端将加密之后的客户端密钥发送给服务器端
* 6）服务器接收到客户端发来的密文后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
* 7）然后服务器端将加密后的密文发送给客户端
* 8）客户端接收到服务器发过来的密文，用客户端密钥（Client key）对其进行对称解密，得倒服务器发过来的数据。

鉴于非对称性加密速度比对称加密慢，但安全性更高，所以密钥的传输使用非对称加密，数据内容的传输使用对称加密。双向认证除了客户端验证服务器端数字证书的合法性之外，增加了服务器端验证客户端数字证书的合法性，确保可信任的客户端才可以访问服务器。

**【扩展 16-5】HTTPS是如何实现验证身份和验证完整性的？**

**HTTPS校验双方身份的真实性**：

HTTPS通过数字证书来验证双方身份。数字证书主要包含的信息有证书颁发机构、证书颁发机构签名、证书绑定的服务器域名、证书版本、有效期、签名使用的加密算法（非对称算法，如RSA）、公钥等。客户端收到服务器的响应后，先向CA验证证书的合法性（根据证书的签名、绑定的域名等信息），如果校验不通过，就会中止连接，向用户提示证书不安全。

**HTTPS验证数据的完整性**：

网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？通过校验数字签名来验证。

服务器在发送报文之前，会先通过哈希算法(哈希算法能够将任意长度的字符串转化为固定长度的字符串，该过程不可逆，可用来作数据完整性校验)对报文提取定长摘要；然后再用私钥对报文摘要进行加密，作为数字签名；再将数字签名附加到报文末尾发送给客户端。

客户端接收到报文后，先用公钥对服务器下发的数字签名进行解密；然后用与服务端同样的Hash算法重新计算出报文的数字签名；比较解密后的签名与自己计算的签名是否一致，如果不一致，说明数据被篡改过。

同样，客户端发送数据时，通过公钥加密报文摘要，服务器用私钥解密，用同样的方法校验数据的完整性。

[HTTPS身份真实性校验与数据完整性校验](https://www.jianshu.com/p/fb6035dbaf8b)

**【扩展 16-6】使用Charles抓HTTPS的包，其中的原理和流程是什么？**


**Charles抓HTTPS包的原理**：

Charles作为一个“中间人代理”，也就是将自己设置成系统的网络访问代理服务器。当浏览器和服务器通信时，Charles接收服务器的证书，但动态生成一张证书发送给浏览器，也就是说Charles作为中间代理在浏览器和服务器之间通信，所以通信的数据可以被Charles拦截并解密。由于Charles更改了证书，浏览器校验不通过会给出安全警告，所以必须安装Charles的证书后才能进行正常访问。

HTTPS抓包的原理简单来说就是Charles作为“中间人代理”，拿到了 服务器证书公钥 和 HTTPS连接的对称密钥，前提是客户端选择信任并安装Charles的CA证书，否则客户端就会“报警”并中止连接。

**Charles抓HTTPS包的流程**：

![Charles抓取HTTPS包的流程示意图.png](https://upload-images.jianshu.io/upload_images/4164292-b94b70db5cfeed41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* (1)客户端向服务器发起HTTPS请求
* (2)Charles拦截客户端的请求，伪装成客户端向服务器进行请求
* (3)服务器向“客户端”（实际上是Charles）返回服务器的CA证书
* (4)Charles拦截服务器的响应，获取服务器证书公钥，然后自己制作一张证书，将服务器证书替换后发送给客户端。（这一步，Charles拿到了服务器证书的公钥）
* (5)客户端接收到“服务器”（实际上是Charles）的证书后，生成一个对称密钥，用Charles的公钥加密，发送给“服务器”（Charles）
* (6)Charles拦截客户端的响应，用自己的私钥解密对称密钥，然后用服务器证书公钥加密，发送给服务器。（这一步，Charles拿到了对称密钥）
* (7)服务器用自己的私钥解密对称密钥，向“客户端”（Charles）发送响应
* (8)Charles拦截服务器的响应，替换成自己的证书后发送给客户端
* (9)至此，连接建立，Charles获取了服务器证书的公钥，也获取了客户端与服务器协商的对称密钥，之后就可以解密或者修改加密的报文了。

[浅谈Charles抓取HTTPS原理](https://www.jianshu.com/p/405f9d76f8c4)

**【扩展 16-7】如何使用Charles抓HTTPS的包？**

[使用Charles进行HTTPS抓包的具体操作](https://www.jianshu.com/p/7a88617ce80b)


**【扩展 16-8】什么是中间人攻击？如何避免？**

**中间人攻击(MITM攻击)的定义**：中间人攻击即所谓的Main-in-the-middle attack(MITM)，是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。

简单来说，攻击者在请求和响应传输途中，拦截并篡改内容。对于 HTTP 来说，由于设计的简单，不需要太多步骤就可以进行监听和修改报文；在这里主要是针对 HTTPS，HTTPS 使用了 SSL 加密协议，是一种非常安全的机制，目前并没有方法直接对这个协议进行攻击，一般都是在建立 SSL 连接时，利用中间人获取到 CA证书、非对称加密的公钥、对称加密的密钥；有了这些条件，就可以对请求和响应进行拦截和篡改。

**避免措施**：

* (1)对于SSL证书欺骗攻击，客户端不要轻易信任证书，只使用默认的系统校验；如果是使用WebView浏览网页，需要在UIWebView中加入较强的授权校验，禁止用户在校验失败的情况下继续访问。
* (2)对于SSL剥离攻击（SSLStrip），在WebView中打开网页同样需要注意，在非全网HTTPS的网站，建议对WebView中打开的URL做检查，检查应该使用 “https://” 的URL是否被篡改为 “http://” ；也建议服务端在配置HTTPS服务时，加上“HTTP Strict Transport Security”配置项。
* (3)针对SSL算法进行攻击，不要随意连入公共场合内的WiFi，也不要使用未知代理服务器；不要安装不可信或突然出现的描述文件，信任伪造的证书；App内部需对服务器证书进行单独的对比校验，确认证书不是伪造的；

[MITM攻击(中间人攻击)](https://www.jianshu.com/p/a825de42ccbc)


**【扩展 16-9】TCP和UDP的区别是什么，他们位于哪一层？**

**TCP协议**:是面向有连接的协议，也就是说在使用TCP协议传输数据之前一定要在发送方和接收方之间建立连接。建立连接后，通过数据超时重传、流量控制、拥塞控制等功能，TCP协议能够正确处理丢包问题，保证接收方能够收到数据，同时还能有效利用网络带宽。

**UDP协议**:是面向无连接的协议，它只会把数据传递给接收端，但不会关注接收端是否收到数据。

TCP和UDP的区别：

* (1)连接性：TCP协议是面向有连接的协议，要先确保发送发和接收方之间建立连接(三次握手)才能进行通信；UDP协议是面向非连接的协议，也就是说发送数据之前不需要建立连接；
* (2)传输可靠性：TCP传输可靠，UDP传输不可靠。TCP协议提供可靠性传输服务，可保证数据无差错、不丢失、不重复且按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是尽最大努力交付，即便是按序发送的序列，也不保证按序送到。
* (3)应用场景：TCP适用于传输大量的数据，对可靠性要求较高的场景；UDP适用于对高速传输和实时性有较高要求的场景（视频、音频等多媒体通信（即时通信））；
* (4)速度方面：TCP传输速度慢；UDP传输速度快
* (5)控制机制：TCP有流量控制、拥塞控制和重发控制等机制，UDP没有，网络拥堵不会影响发送端的发送速率
* (6)开销方面：TCP开销大，TCP首部需20个字节（不算可选项）；UDP开销小，首部字段只需8个字节。
* (7)服务性质方面：TCP是一对一、点到点的连接，而UDP则可以支持一对一，一对多，多对一和多对多的交互通信。
* (8)传输内容方面：TCP面向的是字节流的服务，TCP把数据看成一连串无结构的字节流；UDP面向的是报文的服务，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。
* (9)信道方面：TCP是全双工的可靠信道；UDP是不可靠信道。 

TCP和UDP都位于OSI七层模型的第四层：**传输层**

OSI七层协议：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。

TCP/IP的体系结构：应用层、传输层(TCP、UDP)、网际层IP、网络接口层



**【扩展 16-10】路由器和交换机的工作原理大概是什么，他们分别用到什么协议，位于哪一层？**

[路由器和交换机的工作原理](https://www.jianshu.com/p/5553ada4a881)

**【扩展 16-11】描述TCP 协议三次握手，四次挥手的过程。**

**三次握手(3 way handshake):**

* 第一次握手：建立连接时首先客户端将标志位SYN置为1，并随机生成一个序列值Seq = x，并将该数据包发送给服务端,客户端进入SYN_SENT状态，等待服务端确认；
* 第二次握手：服务端收到客户端发过来的数据包后由标志位SYN=1可知客户端请求建立连接，服务端将标志位SYN和ACK都置为1，ACK = x + 1，随机产生一个值seq = y, 并将该数据包发送给客户端以确认连接请求，服务端进入SYN_RCVD状态；
* 第三次握手：客户端收到确认后，检查ACK是否为x+1，ACK是否为1，如果符合的话，则将标志位ACK置为1，ACK = y + 1, 并将该数据包发送给服务端,服务端检查ACK是否为y+1，ACK是否为1，如果都正确则连接建立成功，客户端和服务端进入ESTABLISHED状态，完成三次握手，随后客户端与服务端之间开始进行数据传输。


**【扩展 16-12】TCP 协议是如何进行流量控制，拥塞控制的？**

**【扩展 16-13】为什么建立连接时是三次握手，两次行不行？如果第三次握手失败了怎么处理？**

**【扩展 16-14】关闭连接时，第四次握手失败怎么处理？**

**【扩展 16-15】你怎么理解分层和协议？**

**【扩展 16-16】HTTP 请求中的 GET 和 POST 的区别，Session 和 Cookie 的区别。**

**【扩展 16-17】谈谈你对 HTTP 1.1，2.0 和 HTTPS 的理解**








































