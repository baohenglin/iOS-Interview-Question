## 知识点14  修饰符

**【扩展 14-1】讲一下iOS属性修饰符atomic的实现机制(内部是怎么实现的)；为什么不能保证绝对的线程安全（最好可以结合场景来说）？**

atomic表示原子操作，系统会为setter方法加锁，具体适用@synchronized(self){//code},保证读写互斥，即读取的时候不能修改值，修改值的时候不能读取，以保证线程安全。

使用atomic并不能保证绝对的线程安全。因为atomic只能保证对属性的读写是原子性的，但是仍然可能出现线程错误。比如：当线程A进行写操作时，其他线程的读或者写操作会因为该操作而等待，当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获取了在B线程中的值，这就破坏了线程安全。如果有线程C在A线程读操作之前release了该属性，那么将会导致程序崩溃。所以仅仅使用atomic并不能保证线程安全，只是保证了属性getter和setter方法的线程安全。

**【扩展 14-2】成员变量、实例变量和属性的区别和联系？**

* （1）成员变量：成员变量是定义在{}中的变量，如果成员变量的数据类型是一个类，则称该变量为实例变量(实例变量是针对类而言的)，所以实例变量是成员变量的一种特殊情况。成员变量不会生成set、get方法，所以成员变量无法被外界访问（只用于类内部），这个也就是所谓的类私有变量。

* （2）属性：使用@property声明的变量是属性，属性可以被外界访问。例如：@property (nonatomic, strong) UIButton *myButton;编译器会自动地生成一个实例变量"_myButton"，同时会生成myButton属性的getter/setter方法。在.m文件中可以直接使用实例变量_myButton，也可以通过属性self.myButton，这里的self.myButton其实是调用myButton属性的getter/setter方法。这与C++中的点方法的使用是有区别的，C++中的点方法可以直接访问成员变量。声明属性myButton后，如果.m文件中写了@synthesize myButton;那么自动生成的实例变量为myButton而不是_myButton。@synthesize的作用是生成与属性对应的实例变量，并让编译器自动生成setter和getter方法。

【注意】类与分类(Category)中添加的属性要区分开来，因为类别中只能添加方法，不能添加实例变量。即使在类别中添加了属性，也不会自动生成带下划线的实例变量，这里其实只是添加的getter与setter方法的声明，并没有getter和setter方法的实现。此外类扩展（匿名类别）是可以添加实例变量的。

【使用建议】:(1)如果只是单纯的private变量，最好声明在implementation里；（2）如果是类的public属性，就用@property写在.h文件里；（3）如果自己内部需要setter和getter来实现一些功能，就在.m文件里用property来声明。

**【扩展 14-3】被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？**

[参考链接](https://www.jianshu.com/p/10c0f49f4755)


## 知识点15  UI视图

**【扩展 15-1】哪些场景可以触发离屏渲染？（知道多少说多少）**

**【扩展 15-2】说说你对 OC 中 load 方法和 initialize 方法的异同。——主要说一下执行时间，各自用途，没实现子类的方法会不会调用父类的？**

**【扩展 15-3】UIView 生命周期**

**【扩展 15-4】如果页面 A 跳转到 页面 B，A 的 viewDidDisappear 方法和 B 的 viewDidAppear 方法哪个先调用？**

**【扩展 15-5】细致地讲一下事件传递流程**



## 知识点16  计算机网络及网络安全

**【扩展 16-1】App网络层有哪些优化策略？**

**【扩展 16-2】TCP为什么要三次握手，四次挥手？**

**【扩展 16-3】对称加密和非对称加密的区别？分别有哪些算法来实现这两种加密？**

**【扩展 16-4】HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么？**

HTTPS=HTTP+SSL/TLS，在HTTP的基础上又加了一层安全加密处理。HTTPS握手流程可细分为8步：

* 1）客户端向服务器端发起HTTPS请求。
* 2）服务器端接受请求。此时服务器端会生成一对密钥，即公钥和私钥，用来进行非对称加密使用。服务器端保存私钥，公钥可以发送给任何人。
* 3）服务器端将自己的公钥和数字证书发送给客户端。
* 4）客户端收到服务器端返回的数字证书后，会对数字证书的合法性进行校验。如何数字证书合法，客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称为客户端密钥（Client key）。然后用服务器端返回的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成蜜文了。
* 5）客户端将加密之后的客户端密钥发送给服务器端
* 6）服务器接收到客户端发来的密文后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
* 7）然后服务器端将加密后的密文发送给客户端
* 8）客户端接收到服务器发过来的密文，用客户端密钥（Client key）对其进行对称解密，得倒服务器发过来的数据。

鉴于非对称性加密速度比对称加密慢，但安全性更高，所以密钥的传输使用非对称加密，数据内容的传输使用对称加密。双向认证除了客户端验证服务器端数字证书的合法性之外，增加了服务器端验证客户端数字证书的合法性，确保可信任的客户端才可以访问服务器。

**【扩展 16-5】HTTPS是如何实现验证身份和验证完整性的？**

**【扩展 16-6】如何使用Charles抓HTTPS的包？其中的原理和流程是什么？**

**【扩展 16-7】如何使用Charles抓HTTPS的包？其中的原理和流程是什么？**

**【扩展 16-8】什么是中间人攻击？如何避免？**

**【扩展 16-9】TCP和UDP区别，他们位于哪一层？**

**【扩展 16-10】路由器和交换机的工作原理大概是什么，他们分别用到什么协议，位于哪一层？**

**【扩展 16-11】描述TCP 协议三次握手，四次释放的过程。**

**【扩展 16-12】TCP 协议是如何进行流量控制，拥塞控制的？**

**【扩展 16-13】为什么建立连接时是三次握手，两次行不行？如果第三次握手失败了怎么处理？**

**【扩展 16-14】关闭连接时，第四次握手失败怎么处理？**

**【扩展 16-15】你怎么理解分层和协议？**

**【扩展 16-16】HTTP 请求中的 GET 和 POST 的区别，Session 和 Cookie 的区别。**

**【扩展 16-17】谈谈你对 HTTP 1.1，2.0 和 HTTPS 的理解**


## 知识点17  操作系统与编译原理

**【扩展 17-1】了解编译的过程么？分为哪几个步骤？**

**【扩展 17-2】静态链了解么？静态库和动态库的区别？**

**【扩展 17-3】内存的几大区域，各自的职能分别是什么？**

**【扩展 17-4】static和const有什么区别？**

**【扩展 17-5】了解内联函数么？**

**【扩展 17-6】源代码是怎么变成可执行文件的，每一步的作用是什么？（预编译，词法分析，语法分析，语义分析，中间语言生成目标代码生成，汇编，链接）**

**【扩展 17-7】应用层、API、运行库、系统调用、操作系统内核之间的关系是什么？**

**【扩展 17-8】虚拟内存空间是什么，为什么要有虚拟内存空间？**

**【扩展 17-9】静态链接和动态链接分别表示什么，大概是怎么实现的？**

**【扩展 17-10】可执行文件的结构如何？（分为哪些段）**

**【扩展 17-11】它是怎么装载进内存的，为什么要分段，分页，页错误是什么？**

**【扩展 17-12】进程的内存格局是怎样的？（堆、栈、全局/静态区，代码区，常量区）**

**【扩展 17-13】堆和栈的区别，函数调用和栈的关系？**

**【扩展 17-14】进程和线程的区别？**

**【扩展 17-15】异步和同步，串行，并发，并行的区别？**

**【扩展 17-16】多并发任务，仅多线程能加快速度么（不能，会变慢，有线程切换的开销）？**

**【扩展 17-17】多个线程之间可以共享哪些数据？**

**【扩展 17-18】进程之间如何通信？**

**【扩展 17-19】介绍几种锁，他们的用途和区别？**


## 知识点18 第三方库 & 组件化

**【扩展 18-1】介绍自己用过哪些开源库？**

Masonry 和 SnapKit，AFNetWorking，MKNetworkKit，Alamofire，Mantle，SDWebImage

**【扩展 18-2】读过某个库的源码么？**

**【扩展 18-3】SDWebImage 下载了图片后为什么要解码？**

**【扩展 18-4】项目有没有做过组件化？或者你是否调研过？**
































