## 知识点14  修饰符

**【扩展 14-1】讲一下iOS属性修饰符atomic的实现机制(内部是怎么实现的)；为什么不能保证绝对的线程安全（最好可以结合场景来说）？**

atomic表示原子操作，系统会为setter方法加锁，具体适用@synchronized(self){//code},保证读写互斥，即读取的时候不能修改值，修改值的时候不能读取，以保证线程安全。

使用atomic并不能保证绝对的线程安全。因为atomic只能保证对属性的读写是原子性的，但是仍然可能出现线程错误。比如：当线程A进行写操作时，其他线程的读或者写操作会因为该操作而等待，当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获取了在B线程中的值，这就破坏了线程安全。如果有线程C在A线程读操作之前release了该属性，那么将会导致程序崩溃。所以仅仅使用atomic并不能保证线程安全，只是保证了属性getter和setter方法的线程安全。

**【扩展 14-2】成员变量、实例变量和属性的区别和联系？**

* （1）成员变量：成员变量是定义在{}中的变量，如果成员变量的数据类型是一个类，则称该变量为实例变量(实例变量是针对类而言的)，所以实例变量是成员变量的一种特殊情况。成员变量不会生成set、get方法，所以成员变量无法被外界访问（只用于类内部），这个也就是所谓的类私有变量。

* （2）属性：使用@property声明的变量是属性，属性可以被外界访问。例如：@property (nonatomic, strong) UIButton *myButton;编译器会自动地生成一个实例变量"_myButton"，同时会生成myButton属性的getter/setter方法。在.m文件中可以直接使用实例变量_myButton，也可以通过属性self.myButton，这里的self.myButton其实是调用myButton属性的getter/setter方法。这与C++中的点方法的使用是有区别的，C++中的点方法可以直接访问成员变量。声明属性myButton后，如果.m文件中写了@synthesize myButton;那么自动生成的实例变量为myButton而不是_myButton。@synthesize的作用是生成与属性对应的实例变量，并让编译器自动生成setter和getter方法。

【注意】类与分类(Category)中添加的属性要区分开来，因为类别中只能添加方法，不能添加实例变量。即使在类别中添加了属性，也不会自动生成带下划线的实例变量，这里其实只是添加的getter与setter方法的声明，并没有getter和setter方法的实现。此外类扩展（匿名类别）是可以添加实例变量的。

【使用建议】:(1)如果只是单纯的private变量，最好声明在implementation里；（2）如果是类的public属性，就用@property写在.h文件里；（3）如果自己内部需要setter和getter来实现一些功能，就在.m文件里用property来声明。

**【扩展 14-3】被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？**

[参考链接](https://www.jianshu.com/p/10c0f49f4755)


## 知识点15  UI视图

**【扩展 15-1】哪些场景可以触发离屏渲染？（知道多少说多少）**







