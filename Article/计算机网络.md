## 知识点1  计算机网络及网络安全

**【扩展 1-1】App网络层有哪些优化策略？**

* (1)优化DNS解析和缓存

APP内置Server IP列表，该列表可以在App启动服务中下发更新。App启动后的首次网络服务会从Server IP列表中取一个IP地址进行TCP连接，同时DNS解析会并行进行，DNS成功后，会返回最适合用户网络的Server IP，那么这个Server IP会被加入到Server IP列表中被优先使用。

Server IP列表有权重机制的，DNS解析返回的IP很明显具有最高的权重，每次从Server IP列表中取IP会取权重最高的IP。列表中IP权重也是动态更新的，根据连接或者服务的成功失败来动态调整，这样即使DNS解析失败，用户在使用一段时间后也会选取到适合的Server IP。

* (2)网络质量检测（根据网络质量来改变策略）

根据用户是在2G/3G/4G/Wi-Fi的网络环境来设置不同的超时参数，以及网络服务的并发数量。比如在环境比较差的情况下:

✅将并发数设置为一个，改成串行；

✅动态设置超时时间；

✅throttle 进行节流。AFNetworking中的throttle方法

```
- (void)throttleBandwidthWithPacketSize:(NSUInteger)numberOfBytes 
```

✅管道化连接。如果服务器不支持管线化的话，那么响应就会乱序。所以服务器要支持。 AFNetworking中通过HTTPShouldUsePipelining属性来设置，默认为NO。

* (3)减少数据传输量：选择合适的数据格式进行传输，比如使用Protocol Buffer数等，使用WebP图片格式。
* (4)提供网络服务重发机制：当第一次网络请求失败的时候，自动尝试再次重发
* (5)使用HTTP缓存。

[iOS网络层详解和优化](http://www.cocoachina.com/articles/22608)

**【扩展 1-2】TCP为什么要三次握手，四次挥手？三次挥手不行吗？（重点）**

**TCP三次握手的原因**：

假如现在客户端想向服务端进行握手，它发送了第一个连接的请求报文，但是由于网络信号差或者服务器负载过多，这个请求没有立即到达服务端，而是在某个网络节点中长时间的滞留了，以至于滞留到客户端连接释放以后的某个时间点才到达服务端，那么这就是一个失效的报文，但是服务端接收到这个失效的请求报文后，就误认为客户端又发了一次连接请求，服务端就会想向客户端发出确认的报文，表示同意建立连接。
假如不采用三次握手，那么只要服务端发出确认，表示新的建立就连接了。但是现在客户端并没有发出建立连接的请求，其实这个请求是失效的请求，一切都是服务端在自相情愿，因此客户端是不会理睬服务端的确认信息，也不会向服务端发送确认的请求，但是服务器却认为新的连接已经建立起来了，并一直等待客户端发来数据，这样的情况下，服务端的很多资源就没白白浪费掉了。
采用三次握手的办法就是为了防止上述这种情况的发生，比如就在刚才的情况下，客户端不会向服务端发出确认的请求，服务端会因为收不到确认的报文，就知道客户端并没有要建立连接，那么服务端也就不会去建立连接，这就是三次握手的作用。

**TCP四次挥手的原因**：

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，在客户端想要断开连接时，客户端向服务端发送FIN报文，只是表示客户端已经没有数据要发送了，但是这个时候客户端还是可以接收来自服务端的数据。

当服务端接收到FIN报文，并返回ACK报文，表示服务端已经知道了客户端要断开连接，客户端已经没有数据要发送了，但是这个时候服务端可能依然有数据要传输给客户端。当服务端的数据传输完之后，服务端会发送FIN报文给客户端，表示服务端也没有数据要传输了，服务端同意关闭连接，之后，客户端收到FIN报文，立即发送给客户端一个ACK报文，确定关闭连接。在之后，客户端和服务端彼此就愉快的断开了这次的TCP连接。

为什么服务端的ACK报文和FIN报文都是分开发送的，但是在三次握手的时候却是ACK报文和SYN报文是一起发送的，因为在三次握手的过程中，当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是在关闭连接时，当服务端接收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，你发的FIN报文我收到了，只有等到服务端所有的数据都发送完了，才能发送FIN报文，因此ACK报文和FIN报文不能一起发送。所以断开连接的时候才需要四次挥手来完成。

三次挥手不行。因为当服务端接收到FIN报文，并返回ACK报文，仅表示服务端已经知道了客户端要断开连接，客户端已经没有数据要发送了，但是这个时候服务端可能依然有数据要传输给客户端。需要将这种特殊情况考虑进去。

**【扩展 1-3】对称加密和非对称加密的区别？分别有哪些算法来实现这两种加密？**

**对称加密**又称**公开密钥加密**，加密和解密都会用到同一个密钥，加解密速度快。由于密钥需要在网络中传输，如果密钥被攻击者获得，此时加密就失去了意义。所以安全性不高。常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。

**非对称加密**又称**共享密钥加密**，使用一对非对称的密钥，一把叫做私钥，另一把叫做公钥；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。加解密速度慢，但安全性更高。常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、ECC(椭圆曲线加密算法）。

**【扩展 1-4】HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么？（重点）**

HTTPS=HTTP+SSL/TLS，在HTTP的基础上又加了一层安全加密处理。HTTPS握手流程可细分为8步：

* 1）客户端向服务器端发起HTTPS请求。
* 2）服务器端接受请求。此时服务器端会生成一对密钥，即公钥和私钥，用来进行非对称加密使用。服务器端保存私钥，公钥可以发送给任何人。
* 3）服务器端将自己的公钥和数字证书发送给客户端。
* 4）客户端收到服务器端返回的数字证书后，会对数字证书的合法性进行校验。如何数字证书合法，客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称为客户端密钥（Client key）。然后用服务器端返回的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了。
* 5）客户端将加密之后的客户端密钥发送给服务器端
* 6）服务器接收到客户端发来的密文后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
* 7）然后服务器端将加密后的密文发送给客户端
* 8）客户端接收到服务器发过来的密文，用客户端密钥（Client key）对其进行对称解密，得倒服务器发过来的数据。

鉴于非对称性加密速度比对称加密慢，但安全性更高，所以密钥的传输使用非对称加密，数据内容的传输使用对称加密。双向认证除了客户端验证服务器端数字证书的合法性之外，增加了服务器端验证客户端数字证书的合法性，确保可信任的客户端才可以访问服务器。

**【扩展 1-5】HTTPS是如何实现验证身份和验证完整性的？**

**HTTPS校验双方身份的真实性**：

HTTPS通过数字证书来验证双方身份。数字证书主要包含的信息有证书颁发机构、证书颁发机构签名、证书绑定的服务器域名、证书版本、有效期、签名使用的加密算法（非对称算法，如RSA）、公钥等。客户端收到服务器的响应后，先向CA验证证书的合法性（根据证书的签名、绑定的域名等信息），如果校验不通过，就会中止连接，向用户提示证书不安全。

**HTTPS验证数据的完整性**：

网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？通过校验数字签名来验证。

服务器在发送报文之前，会先通过哈希算法(哈希算法能够将任意长度的字符串转化为固定长度的字符串，该过程不可逆，可用来作数据完整性校验)对报文提取定长摘要；然后再用私钥对报文摘要进行加密，作为数字签名；再将数字签名附加到报文末尾发送给客户端。

客户端接收到报文后，先用公钥对服务器下发的数字签名进行解密；然后用与服务端同样的Hash算法重新计算出报文的数字签名；比较解密后的签名与自己计算的签名是否一致，如果不一致，说明数据被篡改过。

同样，客户端发送数据时，通过公钥加密报文摘要，服务器用私钥解密，用同样的方法校验数据的完整性。

[HTTPS身份真实性校验与数据完整性校验](https://www.jianshu.com/p/fb6035dbaf8b)

**【扩展 1-6】使用Charles抓HTTPS的包，其中的原理和流程是什么？**


**Charles抓HTTPS包的原理**：

Charles作为一个“中间人代理”，也就是将自己设置成系统的网络访问代理服务器。当浏览器和服务器通信时，Charles接收服务器的证书，但动态生成一张证书发送给浏览器，也就是说Charles作为中间代理在浏览器和服务器之间通信，所以通信的数据可以被Charles拦截并解密。由于Charles更改了证书，浏览器校验不通过会给出安全警告，所以必须安装Charles的证书后才能进行正常访问。

HTTPS抓包的原理简单来说就是Charles作为“中间人代理”，拿到了 服务器证书公钥 和 HTTPS连接的对称密钥，前提是客户端选择信任并安装Charles的CA证书，否则客户端就会“报警”并中止连接。

**Charles抓HTTPS包的流程**：

![Charles抓取HTTPS包的流程示意图.png](https://upload-images.jianshu.io/upload_images/4164292-b94b70db5cfeed41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* (1)客户端向服务器发起HTTPS请求
* (2)Charles拦截客户端的请求，伪装成客户端向服务器进行请求
* (3)服务器向“客户端”（实际上是Charles）返回服务器的CA证书
* (4)Charles拦截服务器的响应，获取服务器证书公钥，然后自己制作一张证书，将服务器证书替换后发送给客户端。（这一步，Charles拿到了服务器证书的公钥）
* (5)客户端接收到“服务器”（实际上是Charles）的证书后，生成一个对称密钥，用Charles的公钥加密，发送给“服务器”（Charles）
* (6)Charles拦截客户端的响应，用自己的私钥解密对称密钥，然后用服务器证书公钥加密，发送给服务器。（这一步，Charles拿到了对称密钥）
* (7)服务器用自己的私钥解密对称密钥，向“客户端”（Charles）发送响应
* (8)Charles拦截服务器的响应，替换成自己的证书后发送给客户端
* (9)至此，连接建立，Charles获取了服务器证书的公钥，也获取了客户端与服务器协商的对称密钥，之后就可以解密或者修改加密的报文了。

[浅谈Charles抓取HTTPS原理](https://www.jianshu.com/p/405f9d76f8c4)

**【扩展 1-7】如何使用Charles抓HTTPS的包？**

[使用Charles进行HTTPS抓包的具体操作](https://www.jianshu.com/p/7a88617ce80b)


**【扩展 1-8】什么是中间人攻击？如何避免？**

**中间人攻击(MITM攻击)的定义**：中间人攻击即所谓的Main-in-the-middle attack(MITM)，是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。

简单来说，攻击者在请求和响应传输途中，拦截并篡改内容。对于 HTTP 来说，由于设计的简单，不需要太多步骤就可以进行监听和修改报文；在这里主要是针对 HTTPS，HTTPS 使用了 SSL 加密协议，是一种非常安全的机制，目前并没有方法直接对这个协议进行攻击，一般都是在建立 SSL 连接时，利用中间人获取到 CA证书、非对称加密的公钥、对称加密的密钥；有了这些条件，就可以对请求和响应进行拦截和篡改。

**避免措施**：

* (1)对于SSL证书欺骗攻击，客户端不要轻易信任证书，只使用默认的系统校验；如果是使用WebView浏览网页，需要在UIWebView中加入较强的授权校验，禁止用户在校验失败的情况下继续访问。
* (2)对于SSL剥离攻击（SSLStrip），在WebView中打开网页同样需要注意，在非全网HTTPS的网站，建议对WebView中打开的URL做检查，检查应该使用 “https://” 的URL是否被篡改为 “http://” ；也建议服务端在配置HTTPS服务时，加上“HTTP Strict Transport Security”配置项。
* (3)针对SSL算法进行攻击，不要随意连入公共场合内的WiFi，也不要使用未知代理服务器；不要安装不可信或突然出现的描述文件，信任伪造的证书；App内部需对服务器证书进行单独的对比校验，确认证书不是伪造的；

[MITM攻击(中间人攻击)](https://www.jianshu.com/p/a825de42ccbc)


**【扩展 1-9】TCP和UDP的区别是什么，他们位于哪一层？**

**TCP协议**:是面向有连接的协议，也就是说在使用TCP协议传输数据之前一定要在发送方和接收方之间建立连接。建立连接后，通过数据超时重传、流量控制、拥塞控制等功能，TCP协议能够正确处理丢包问题，保证接收方能够收到数据，同时还能有效利用网络带宽。

**UDP协议**:是面向无连接的协议，它只会把数据传递给接收端，但不会关注接收端是否收到数据。

TCP和UDP的区别：

* (1)连接性：TCP协议是面向有连接的协议，要先确保发送发和接收方之间建立连接(三次握手)才能进行通信；UDP协议是面向非连接的协议，也就是说发送数据之前不需要建立连接；
* (2)传输可靠性：TCP传输可靠，UDP传输不可靠。TCP协议提供可靠性传输服务，可保证数据无差错、不丢失、不重复且按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是尽最大努力交付，即便是按序发送的序列，也不保证按序送到。
* (3)应用场景：TCP适用于传输大量的数据，对可靠性要求较高的场景；UDP适用于对高速传输和实时性有较高要求的场景（视频、音频等多媒体通信（即时通信））；
* (4)速度方面：TCP传输速度慢；UDP传输速度快
* (5)控制机制：TCP有流量控制、拥塞控制和重发控制等机制，UDP没有，网络拥堵不会影响发送端的发送速率
* (6)开销方面：TCP开销大，TCP首部需20个字节（不算可选项）；UDP开销小，首部字段只需8个字节。
* (7)服务性质方面：TCP是一对一、点到点的连接，而UDP则可以支持一对一，一对多，多对一和多对多的交互通信。
* (8)传输内容方面：TCP面向的是字节流的服务，TCP把数据看成一连串无结构的字节流；UDP面向的是报文的服务，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。
* (9)信道方面：TCP是全双工的可靠信道；UDP是不可靠信道。 

TCP和UDP都位于OSI七层模型的第四层：**传输层**

OSI七层协议：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。

TCP/IP的体系结构：应用层、传输层(TCP、UDP)、网际层IP、网络接口层



**【扩展 1-10】路由器和交换机的工作原理大概是什么，他们分别用到什么协议，位于哪一层？**

[路由器和交换机的工作原理](https://www.jianshu.com/p/5553ada4a881)

**【扩展 1-11】描述TCP 协议三次握手，四次挥手的过程。（重点）**

**三次握手(Three-way Handshaking):**

[三次握手详解](http://c.biancheng.net/view/2351.html)

* 第一次握手：建立连接时首先客户端将标志位SYN置为1，并随机生成一个序列值seq = x，并将该数据包发送给服务端,客户端进入SYN_SENT状态，等待服务端确认；
* 第二次握手：服务端收到客户端发过来的数据包后由标志位SYN=1可知客户端请求建立连接，服务端将标志位SYN和ACK都置为1，ack = x + 1，随机产生一个值seq = y, 并将该数据包发送给客户端以确认连接请求，服务端进入SYN_RCVD状态；
* 第三次握手：客户端收到确认后，检查ack是否为x+1，ACK是否为1，如果符合的话，则将标志位ACK置为1，ack = y + 1, 并将该数据包发送给服务端,服务端检查ack是否为y+1，ACK是否为1，如果都正确则连接建立成功，客户端和服务端进入ESTABLISHED状态，完成三次握手，随后客户端与服务端之间开始进行数据传输。

**四次挥手：**

[四次挥手详解](http://c.biancheng.net/view/2353.html)

* 第一次挥手：客户端发出连接释放的报文，并且停止发送数据。将释放数据报文首部的FIN置为1，序列号seq 置为u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
* 第二次挥手：服务端收到报文后，检查到首部的FIN为1，知道客户端请求释放连接，服务端发出确认报文，并将报文首部的ACK置为1，ack置为u + 1,并且带上自己的序列号v,此时服务端进入CLOSE-WAIT(关闭等待状态)。客户端收到服务端的确认报文后，检查ACK是否为1，ack是否为u+1,如果都正确，客户端进入FIN-WAIT-2(终止等待2)状态。等待服务端发送连接释放报文。
* 第三次挥手：服务端将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1,ack = u+1,序列号为seq = w(因为在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w)，此时服务端进入LASK-ACK(最后确认)状态，等待客户端确认。
* 第四次挥手：客户端接收服务器的报文后，检查FIN为1，知道服务端请求释放连接，发出确认报文，ACK = 1， ack = w + 1, seq = u + 1, 此时客户端进入TIME-WAIT(时间等待)状态。服务端只要收到客户端发出的确认报文，检查ACK是否为1，ack 是否为 w + 1, 如果都正确，立即进入CLOSE状态。

[三次握手和四次挥手详解](https://www.jianshu.com/p/5553ada4a881)

[TCP 数据传输过程详解](http://c.biancheng.net/view/2352.html)

**【扩展 1-12】TCP 协议是如何进行流量控制，拥塞控制的？（重点）**

**TCP流量控制原理:**

流量控制以动态调整发送空间大小(滑动窗口)的形式来反映接收端接收消息的能力，反馈给发送端以调整发送速度，避免发送速度过快导致的丢包或者过慢降低整体性能。

这里采用滑动窗口机制，一是不用每次发送完成都需要等待收到确认消息才能继续发送，二是参考接收端的接收能力，限制发送数据段大小，避免丢失现象。

**TCP拥塞控制原理:**

连接建立的初期，如果窗口比较大，发送方可能会突然发送大量数据，导致网络瘫痪。因此，在通信一开始时，TCP 会通过慢启动算法得出窗口的大小，对发送数据量进行控制。

流量控制是由发送方和接收方共同控制的。接收方会把自己能够承受的最大窗口长度写在TCP 首部中，实际上在发送方这里，也存在流量控制，它叫拥塞窗口。TCP 协议中的窗口是指发送方窗口和接收方窗口的较小值。

**慢启动过程**如下：

![拥塞控制窗口大小调整.png](https://upload-images.jianshu.io/upload_images/4164292-f38ca5ade0b122ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 通信开始时，发送方的拥塞窗口大小为1。每收到一个 ACK确认后，拥塞窗口翻倍。
* 由于指数级增长非常快，很快地，就会出现确认包超时。(超时是因为数据量大导致网络拥塞)。
* 此时设置一个“慢启动阈值”，它的值是当前拥塞窗口大小的一半。同时将拥塞窗口大小设置为1，重新进入慢启动过程
* 由于现在“慢启动阈值”已经存在，当拥塞窗口大小达到阈值时，不再翻倍，而是线性增加。
* 随着窗口大小不断增加，可能收到三次重复确认应答，进入“快速重发”阶段。(快速重发: 当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。当收到三个表示同一个数据段的ack时，不需要等待计时器超时，即重新发送数据段（当时这三个ack要在超时之前到达发送端），因为能够收到接收端的ack确认信息，所以数据段只是单纯的丢失，而不是因为网络拥塞导致。)
* 这时候，TCP 将“慢启动阈值”设置为当前拥塞窗口大小的一半，再将拥塞窗口大小设置成阈值大小（也有说加 3）。
* 拥塞窗口又会线性增加，直至下一次出现三次重复确认应答或超时。



**【扩展 1-13】为什么建立连接时是三次握手，两次行不行？如果第三次握手失败了怎么处理？（重点）**

**建立连接时是三次握手的原因：** 

由于网络是不可靠的，数据包是可能丢失的。假如现在客户端想向服务端进行握手，它发送了第一个连接的请求报文，但是由于网络信号差或者服务器负载过多，这个请求没有立即到达服务端，而是在某个网络节点中长时间的滞留了，以至于滞留到客户端连接释放以后的某个时间点才到达服务端，那么这就是一个失效的报文，但是服务端接收到这个失效的请求报文后，就误认为客户端又发了一次连接请求，服务端就会想向客户端发出确认的报文，表示同意建立连接。

假如不采用三次握手，那么只要服务端发出确认，表示新的建立就连接了。但是现在客户端并没有发出建立连接的请求，其实这个请求是失效的请求，一切都是服务端在自相情愿，因此客户端是不会理睬服务端的确认信息，也不会向服务端发送确认的请求，但是服务器却认为新的连接已经建立起来了，并一直等待客户端发来数据，这样的情况下，服务端的很多资源就没白白浪费掉了。

采用三次握手的办法就是为了防止上述这种情况的发生，比如就在刚才的情况下，客户端不会向服务端发出确认的请求，服务端会因为收不到确认的报文，就知道客户端并没有要建立连接，那么服务端也就不会去建立连接，这就是三次握手的作用。

**第三次握手失败后的处理措施：**

按照 TCP 协议处理丢包的一般方法，服务端会重新向客户端发送数据包，直至收到ACK 确认为止。但实际上这种做法有可能遭到SYN 泛洪攻击。所谓的泛洪攻击，是指发送方伪造多个 IP 地址，模拟三次握手的过程。当服务器返回 ACK 后，攻击方故意不确认，从而使得服务器不断重发 ACK。由于服务器长时间处于半连接状态，最后消耗过多的CPU和内存资源导致死机。

正确处理方法是**服务端发送RST 报文，进入 CLOSE状态**。这个 RST 数据包的 TCP 首部中，控制位中的 RST 位被设置为1。这表示连接信息全部被初始化，原有的 TCP通信不能继续进行。客户端如果还想重新建立TCP 连接，就必须重新开始第一次握手。

**【扩展 1-14】关闭连接时，第四次握手失败怎么处理？**(待优化)

实际上，在第三步中，客户端收到 FIN 包时，它会设置一个计时器，等待相当长的一段时间。如果客户端返回的 ACK 丢失，那么服务端还会重发 FIN 并重置计时器。假设在计时器失效前服务器重发的 FIN 包没有到达客户端，客户端就会进入 CLOSE 状态，从而导致服务端永远无法收到 ACK 确认，也就无法关闭连接。


**【扩展 1-15】你怎么理解分层和协议？**

**分层**

分层的优点：

* 独立性强。通过分层，每一层只接受下一层提供的特定服务，并且负责为上一层提供特定服务，上下层之间进行交互所遵循的约定叫“接口”，同一层之间的交互所遵循的约定叫做“协议”。每一层可以独立使用，及时系统中某些层次发生变化，也不会波及系统。
* 灵活性好。对于任何一层的改动，只要上下层接口不变，都不会造成系统的问题，有利于每一层功能的扩展和变动。
* 易于实现和维护。将大问题简化为小问题，大系统简化为小层次。比如将网络的通信过程划分为小一些、简单一些的部件,因此有助于各个部件的开发、设计和故障排除。
* 能促进标准化工作。通过分层，定义在模型的每一层实现什么功能,有利于鼓励产业的标准化，同时允许多个供应商进行开发。

分层的原则：

* 各个层之间有清晰的边界,便于理解;
* 每个层实现特定的功能;
* 层次的划分有利于国际标准协议的制定;
* 层的数目应该足够多，以避免各个层功能重复。

**协议**

协议实际上是一种通信双方共同遵守的规范。比如我需要把性别和年龄传递给另外一台主机，那么我可以定义一个"A 协议"，协议规定数据的前 4 个字节表示性别，后四个字节表示年龄。这样对方主机接收时就知道前 4 个字节是性别，而不会错把它当成年龄来处理。

协议的规范和共同遵守，有利于各个分层之间的交流和处理，也有利于促进协议的标准化过程。

**【扩展 1-16】HTTP 请求中的 GET 和 POST 的区别，Session 和 Cookie 的区别。**


**GET 和 POST 的区别：**

* (1)从用途方面来说，GET 是从服务器获取数据；POST 是向服务器传输实体数据。
* (2)GET方式提交的数据有长度限制(最大 1024 字节)，而 POST 没有限制。其实HTTP协议对GET和POST都没有对长度的限制。HTTP协议明确地指出了，HTTP头和Body都没有长度的要求。之所以说GET提交的数据有长度限制是因为：一方面早期的浏览器会对URL长度做限制，另一方面多数服务器出于安全性、稳定性方面的考虑，会给URL长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。
* (3)POST 请求仅比 GET 请求安全。GET使用URL或Cookie传参（URL中传参暴露了参数，不安全），而POST将参数隐藏在 BODY 中，较安全。因为POST请求的参数不会被保存在浏览器历史记录或 web 服务器日志中。此外，GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL中。通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。
* (4)从服务器解析方面：GET请求从 Request.QueryString 获取变量的值；POST 从 Request.Form 获取提交的数据。

以上四点只是二者在使用方面的区别。GET和POST的本质区别是**GET请求是幂等性的，POST请求不是幂等性的**。什么是幂等性？幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。正因为二者有这样的区别，**所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险**，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。


**Session 和 Cookie 的区别：**

* (1)cookie 保存在客户端，而 session 则保存在服务器中。
* (2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。 
* (3)session 可以设置超时时间，超过这个时间后就失效，以免长期占用服务端内存。
* (4)单个 cookie 的大小有限制（4 Kb），很多浏览器都限制一个站点最多保存20个cookie。
* (5)客户端每次都会把 cookie 发送到服务端，因此服务端可以知道 cookie，但是客户端不知道 session。当服务器接收到 cookie 后，会根据 cookie 中的 SessionID 来找到这个客户的 session。如果没有，则会生成一个新的 SessionID 发送给客户端。
* (6)将登陆信息等重要信息存放为SESSION，其他信息如果需要保存，可以放在COOKIE中。


**token和session的区别：**

* (1)Session 是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端的。
* (2)session需要严格保密，不应该共享给第三方。如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用token。

**cookie的定义**：cookie是保存在本地终端的数据。cookie由服务器生成，发送给客户端，客户端把cookie以键值对形式保存下来，下一次请求同一个URL时会把该cookie发送给服务器。cookie的组成有：名称(name)、值(value)、有效域(domain,可以访问该cookie的域名)、path(域的路径，一般设置为全局:"/")、失效时间、secure(指定后，cookie只有在使用SSL连接时才发送到服务器(https))。

**session的定义**：session的中文翻译是“会话”，当用户打开某个web应用时，便与web服务器产生一次session。服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。

**token的定义**：token的意思是“令牌”，是用户身份的验证方式，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。

**【扩展 1-17】谈谈你对 HTTP 1.1，2.0 和 HTTPS 的理解**

**HTTP**

HTTP（超文本传输协议，HyperText Transfer Protocol)是应用层的协议，目前在互联网中应用广泛。它被设计用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。 HTTP遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。

**HTTP/1.0 ——构建可扩展性**

HTTP/1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。

**HTTP/1.1 ——标准化的协议**

HTTP/1.0的多种不同的实现运用起来有些混乱，HTTP1.1是第一个标准化版本，重点关注的是校正HTTP1.0设计中的结构性缺陷：

* 连接可以重复使用，节省了多次打开它的时间，以显示嵌入到单个原始文档中的资源。
* 增加流水线操作，允许在第一个应答被完全发送之前发送第二个请求，以降低通信的延迟。
* 支持响应分块。
* 引入额外的缓存控制机制。
* 引入内容协商，包括语言，编码，或类型，并允许客户端和服务器约定以最适当的内容进行交换。
* 添加Host 头，能够使不同的域名配置在同一个IP地址的服务器。
* 安全性得到了提高。

在http/1.1中，client和server都是默认对方支持长链接的， 如果不希望使用长链接，则需要在header中指明connection:close。

**HTTP/2.0**

HTTP/2.0在HTTP/1.1有以下几点不同:

* HTTP/2.0是二进制协议而不是文本协议。
* HTTP/2.0是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。
* 压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。
* 其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。

**HTTPS**

我们知道HTTP 协议直接使用了TCP 协议进行数据传输。由于数据没有加密，都是直接明文传输，所以存在以下三个风险：

* 窃听风险：由于通信使用明文(不加密)，内容可能会被窃听；
* 篡改风险：无法证明报文的完整性，所以有可能已遭篡改；
* 冒充风险：不验证通信方的身份，因此有可能遭遇伪装。

HTTPS 协议旨在解决以上三个风险，因此它可以：

* 保证所有信息加密传输，无法被第三方窃取。
* 为信息添加校验机制，如果被第三方恶意破坏，可以检测出来。
* 配备身份证书，防止第三方伪装参与通信。

HTTPS(HTTP Secure安全套接字层超文本传输协议)，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL(Secure Socket Layer)协议，SSL依靠证书来验证服务器的身份，并为客户端和服务器之间的通信加密。即HTTPS=HTTP+SSL/TLS。

HTTPS握手流程可细分为8步：

* 1）客户端向服务器端发起HTTPS请求。
* 2）服务器端接受请求。此时服务器端会生成一对密钥，即公钥和私钥，用来进行非对称加密使用。服务器端保存私钥，公钥可以发送给任何人。
* 3）服务器端将自己的公钥和数字证书发送给客户端。
* 4）客户端收到服务器端返回的数字证书后，会对数字证书的合法性进行校验。如何数字证书合法，客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称为客户端密钥（Client key）。然后用服务器端返回的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了。
* 5）客户端将加密之后的客户端密钥发送给服务器端
* 6）服务器接收到客户端发来的密文后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
* 7）然后服务器端将加密后的密文发送给客户端
* 8）客户端接收到服务器发过来的密文，用客户端密钥（Client key）对其进行对称解密，得倒服务器发过来的数据。

鉴于非对称性加密速度比对称加密慢，但安全性更高，所以密钥的传输使用非对称加密，数据内容的传输使用对称加密。双向认证除了客户端验证服务器端数字证书的合法性之外，增加了服务器端验证客户端数字证书的合法性，确保可信任的客户端才可以访问服务器。

**【扩展 1-18】设计一套大文件（比如上百M的视频）下载方案（重点）**

设计思路：

* NSURLSession；
* 支持断点下载，自动记录停止下载时断点的位置；
* 遵守 NSURLSessionDownloadDelegate 协议
* 使用 NSURLSession 下载大文件，被下载文件会被自动写入沙盒的临时文件夹 temp；
* 下载完毕，通常需要将已下载文件移动到其他位置（temp 文件夹中的数据被定时删除），通常是 cache 文件夹中。

实现代码如下：

```
@property (nonatomic, strong) NSURLSessionDownloadTask *task;
// 获取 NSURLSession 对象
NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]delegate:self delegateQueue:[[NSOperationQueue alloc]init]];
// 初始化下载任务
self.task = [session downloadTaskWithURL:@"此处为下载文件路径的URL"];
// 实现代理方法
// 每当写入数据到临时文件的时候，就会调用一次该方法，通常在该方法中获取下载进度
- (void)URLSession:(NSURLSession)session downloadTask:(NSURLSessionDownloadTask)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExprectedToWrite:(int64_t)totalBytesExprectedToWrite
{
  //计算下载进度
  CGFloat progress = 1.0 * totalBytesWritten / totalBytesExpectedToWrite;
}
//任务终止时调用的方法，通常用于断点下载
- (void)URLSession:(NSURLSession)session downloadTask:(NSURLSessionDownloadTask)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes
{
  //fileOfset 下载任务终止时的偏移量
}
// 遇到错误时调用，error参数只能传递客户端的错误
- (void)URLSession:(NSURLSession)session task:(NSURLSessionTask)task didCompleteWithError:(NSError *)error
{
  
}
//下载完成时调用，需要将文件剪切到可以长期保存的文件夹中
- (void)URLSession:(NSURLSession)session downloadTask:(NSURLSessionDownloadTask)downloadTask didFinishDownloadingToURL:(NSURL *)location
{
  //生成文件长期保存的路径
  NSString *file = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename];
  //获取文件句柄
  NSFileManager *fileManager = [NSFileManager defaultManager];
  // 通过文件句柄，将文件剪切到文件长期保存的路径
  [fileManager moveItemAtURL:location toURL:[NSURL fileURLWithPath:file] error:nil];
}
//开始或继续下载任务
[self.task resume];
// 暂停下载任务
[self.task suspend]
```

**【扩展 1-19】http 请求方法有哪些？**

共有 8 种请求方法。

* GET：**从服务器端获取资源**。向特定的路径资源发出请求。数据暴露在 URL 中了。
* POST：**向指定路径资源提交数据进行处理请求（一般用于上传表单或者文件），数据包含在请求体中**。虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。POST 的主要目的并不是获取相应的主体内容。
* PUT：用来**传输文件**。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件的内容，然后保存到请求 URI 指定的位置。但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。
* DELETE：**删除文件**。是与 PUT 相反的方法。DELETE 方法按照请求 URI 删除指定的资源。但是，鉴于 HTTP/1.1 的 DELETE 方法 和 PUT 方法一样自身不带验证机制，存在安全性问题，因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 DELETE 方法。
* HEAD：用于**获取报文首部**。HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。
* OPTIONS：用来查询针对请求 URI 指定的资源服务器所支持的方法。

```
HTTP/1.1 200 OK
Allow:GET,POST,HEAD,OPTIONS
```
* TRACE：**回显服务器端收到的请求**，主要用于诊断和测试。发送请求时，在 MAX-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。由于 TRACE 方法容易引发 XST（Cross-Site Tracing,跨站跟踪）攻击，通常不会用到此方法。
* CONNECT：**该方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信**。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。


**【扩展 1-20】URL 和 URI**

* URL：统一资源定位符（Uniform Resource Locator）。
* URI：统一资源标识符（Uniform Resource Identifier）。URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。采用 HTTP 协议时，协议方案就是 http。除此之外，还有 ftp、mailto、telnet、file等。标准的 URI 协议方案有 30 种左右。

**【扩展 1-21】Socket 套接字编程**

 * 1）Socket的基本概念:网络上两个程序通过一个双向通信连接实现数据交互，这种双向通信的连接叫做Socket（套接字）。Socket本质:网络模型中应用层与TCP/IP协议族通信的中间软件抽象层，是它的一组编程接口（API），也即对TCP/IP的封装。TCP/IP也要提供可供程序员做网络开发所用的接口，即Socket编程接口。
 * 2）Socket要素有五个：连接使用的协议、本地主机的IP地址、本地进程的协议端口、远程主机的IP地址、远程进程的协议端口。
 * 3）特性：Socket可以支持不同的传输协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接；同理，当使用UDP协议进行连接时，该Socket连接就是一个UDP连接。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，计算机操作系统为应用程序与TCP/IP协议交互提供了套接字（Socket）接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。
 * 4）链接：
     建立Socket连接至少需要一对套接字，分别运行于服务端（ServerSocket）和客户端（ClientSocket）。套接字直接的连接过程氛围三个步骤：
     
     Step 1：服务器监听。服务端Socket始终处于等待连接状态，实时监听是否有客户端请求连接。
     
     Step 2：客户端请求。客户端Socket提出连接请求，指定服务端Socket的地址和端口号，这时就可以向对应的服务端提出Socket连接请求。
     
     Step 3：连接确认。当服务端Socket监听到客户端Socket提出的连接请求时作出响应，建立一个新的进程，把服务端Socket的描述发送给客户端，该描述得到客户端确认后就可建立起Socket连接。而服务端Socket则继续处于监听状态，继续接收其他客户端Socket的请求。
* 5)客户端的步骤为：
    
    ✅ 1、创建一个socket，用函数socket()；
    
    ✅ 2、设置socket属性，用函数setsockopt();
    
    ✅ 3、设置要连接的远程主机IP地址和端口等属性；
    
    ✅ 4、连接服务器，用函数connect()；
    
    ✅ 5、收发数据，用函数send()和recv()，或者read()和write();
    
    ✅ 6、关闭网络连接。

* 6）socket编程[oc]粘包、半包处理方法：在做socket编程时，如果是做tcp连接，那就不可避免的会遇到粘包与半包的问题，粘包就是多组数据被一并接收了,粘在了一起，无法做划分；半包就是有数据接收不完整，无法处理。要解决粘包、半包的问题，一般在设计数据(消息)格式时会约定好一个字段专门用于描述数据包的长度，这样就使数据有了边界，依靠这个边界，就能把每组数据划分出来，数据不完整时也能获知数据的缺失。消息＝消息头＋消息体。消息头用于描述消息本身的基本信息，消息体则为消息的具体内容。


**【扩展 1-22】App 需要加载超大量的数据，给服务器发送请求，但是服务器卡住了，如何解决？**

* 设置请求超时；
* 给用户提示请求超时；
* 根据用户操作再次请求数据。

**【扩展 1-23】HTTP的通信的请求报文、响应报文分别包含哪些内容？OC 中是怎样实现的？**

一个请求报文是由**请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体**构成的。

![请求报文的构成](https://upload-images.jianshu.io/upload_images/4164292-6a07887bf5bea75c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做**请求报文**，响应端（服务器端）的叫做**响应报文**。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。

HTTP报文大致可分为**报文首部**和**报文主体**两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。

![HTTP报文的结构.png](https://upload-images.jianshu.io/upload_images/4164292-465dbefe65ffcf82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![请求报文和响应报文的结构.png](https://upload-images.jianshu.io/upload_images/4164292-922ffad0e1d5fbb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![请求报文和响应报文的实例.png](https://upload-images.jianshu.io/upload_images/4164292-2eb6960bedd560e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

请求行：包含请求方法、请求资源路径、HTTP协议版本。

状态行：包含表明响应结果的状态码、原因短语和 HTTP 版本。

首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。

```
Host:192.168.1.105:8080   //客户端访问的服务器主机地址
User-Agent:Mozilla/5.0(Macintosh;Intel Mac OS X 10.9) Firefox/30.0  //客户端的类型，客户端的软件环境
Accept:text/html //客户端所能接收的数据类型
Accept-Language:zh-cn //客户端的语言环境
Accept-Encoding:gzip //客户端支持的数据压缩格式
请求体：客户端发给服务端的具体数据，比如文件数据
```

发送给服务器端的请求报文包含：

* 请求行：包含请求方法、请求资源路径、HTTP协议版本。
* 请求头：对客户端的环境描述、客户端请求的主机地址等信息；
* 请求体：客户端发给服务器的具体数据。

响应报文包括：

* 状态行：包含表明响应结果的状态码、原因短语和 HTTP 版本。
* 响应头：包含了对服务器的描述、对返回数据的描述
* 首部字段：
* 实体内容：服务器返回给客户端的具体数据，比如文件数据。

OC中响应使用 NSURLRespose。返回给客户端的回应包含：

* 状态行：包含了HTTP协议版本、状态码、状态英文名称；
* 响应头：包含了对服务器的描述、对返回数据的描述；
* 实体内容：服务器返回给客户端的具体二进制数据。



