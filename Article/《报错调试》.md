## 错误调试

**【1-1】BAD_ACCESS 在什么情况下出现？如何调试 BAD_ACCESS 错误？（重点）**

[参考链接](https://www.cnblogs.com/shinianshumu/articles/5679943.html)

* 访问了野指针（悬垂指针）。访问已经释放了的对象的成员变量或者发送消息，比如一个已经释放的对象执行了 release；
* 死循环

**调试方法**：

* 重写 NSObject 的 respondsToSelector 方法，先找出出现 EXEC_BAD_ACCESS 前访问的最后一个 object。
* 通过勾选“Enable Zombie Objects”来定位
* 设置全局断点快速定位
* 通过在配置中勾选“Enable Address Sanitizer”，来定位。Xcode7 已经集成了 BAD_ACCESS 捕获功能：Address Sanitizer。

**【1-2】什么时候会报“unrecognized selector 异常？”（重点）**

当调用对象（子类、各级父类）中都不包含对应方法，并且依旧没有给出“消息转发”的具体方法的时候，程序在运行时会 crash 并抛出 unrecognized selector 异常。

然后可以具体说一下消息机制的三大阶段。

**【1-3】有哪些常见的 Crash 场景？（重点）**

[参考链接](https://www.jianshu.com/p/74247ba1393f)

* 访问了不存在的方法“unrecognized selector sent to instance”。正确做法是在调用方法前先使用 respondsToSelector 判断。

```
NSObject *obj = [[NSObject alloc] init];
if ([obj respondsToSelector:@selector(HLTest)]) {
  [obj HLTest];
}
```
* KVC 造成的 Crash；
* KVO 引起的崩溃；
* 多线程中的崩溃；
* Watch Dog 超时造成的 Crash；
* 访问了僵尸对象。比如重复 release。
* 调用 Block 时没有判断 Block 是否为空。如果 block 为 nil，直接调用会 Crash。

```
if (block) {
  block();
}
```
* 在数组中插入了 nil 对象；
* 数组越界；
* 后台返回 NSNull 导致的崩溃，多见于 Java 做后台服务器开发语言。

**【1-4】lldb（gdb）常用的调试命令**

[lldb常用命令](https://www.cnblogs.com/hjltonyios/p/8878959.html)

* **expression**(expr)： 修改参数值。

```
//expression 打印值
expression width

//expression 修改值
expression width = 80
```

* **打印命令：p 和 po**。二者的区别在于使用 po 只会输出对应的值，而 p 则会返回 值的类型以及引用名。

```
p width //(CGFloat)$10 = 70
po width //70

p endTime   //(_NSCFString *)$14 = 0x0000608000437600 @"08-11 11:43"
po endTime  //08-11 11:43
```

对比结果：

```
po：输出值
p：输出值+值类型+引用名+内存地址（Xcode 中有内存地址）
```

* p/x：转十六进制

```
p 100    //(int)$8 = 100
p/x 100  //(int)$9 = 0x00000064
```
* p/o：转八进制

```
p/o 100  //(int)$10 = 0144
```

* p/t：转二进制

```
p/t 100 //(int)$2 = 0b00000000000000000000000011000100
```

* p/d：字符转十进制数字

```
(lldb)p/d 'A' //(char)$7 = 65
```

* p/c：十进制数字转字符。

```
(lldb)p/c 66 //(int)$10 = B\0\0\0
```

* 堆栈打印（thread bachtrace）：如果嫌堆栈打印太长，可以加一个值限制。

```
(lldb) bt 10 //只打印 10 条
```

**【1-5】如果一个函数 10 次中有 7 次正确，3次错误，问题可能出在哪里？**

从问题的描述可知，bug不是必现的，因此无法直接定位。可以从以下角度来分析：

* 由于出错不是崩溃，因此没有错误日志可以查看。第一步就是分析函数中的所有分支，是否在语法上存在可能缺少条件的问题。
* 检测函数的参数，保证必传参数不能为空。如果为空应该抛出异常。可以通过断言来检测参数的正确性。
* 检测函数中每个分支所调用的函数返回结果是否正确。

**【1-6】你一般是如何调试 Bug 的？**

Bug 分为测试版本Bug 和线上版本 Bug。

* 线上 Bug：项目中使用了友盟统计，因此会有崩溃日志。通过分析 dYSM 可以直接定位到大部分 bug 崩溃之处。解决线上 bug 需要从主干拉取一个新的分支，解决 bug 并测试通过后，再合并到主干，然后上线。若是多团队开发，可以将 fix bug 分支与其他团队最近要上线的分支集成，然后集成测试通过后再上线。
* 测试 Bug：首先根据测试反馈的 bug 描述，先判断 bug 描述是否清晰，如果语义不清晰，可以找到测试人员让他操作复现该 bug。解决 bug 时，如果能根据描述直接定位 bug，则直接解决；如果无法直观定位，则根据 bug 类型分几种处理方式。比如崩溃的 bug 可以通过 Instruments 来检测；数据显示错误的 bug，则需要阅读源码一步步检查。






