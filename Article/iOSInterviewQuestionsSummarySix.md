## 知识点17  操作系统与编译原理

**【扩展 17-1】源代码是怎么变成可执行文件的？每一步的作用是什么？**

源代码变成可执行文件需要经过以下过程：

* (1)预编译：负责这一步工作的叫“预编译器”。它主要负责将所有的#define删除，并且展开所有的宏定义；处理所有的条件预编译指令，比如#if #ifdef #elif #else #endif等；处理#include 预编译指令，将被包含的文件插入到该预编译指令的位置；删除所有注释“//”和”/* */”；添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号；保留所有的#pragma编译器指令，因为编译器需要使用它们；最终.c文件经过预编译，变为.i文件。
* (2)编译：由编译器负责，主要又由词法分析、语法分析、语义分析、优化和生成汇编代码五个部分：

  ✅词法分析———识别源代码中的各种括号、数字、标点等。比如有(但没有)，这一步就能发现错误。
  
  ✅语法分析———这一步会通过语法分析器(Grammar Parser)会生成语法树，比如2+4就是一颗根节点为+，左右叶节点分别为2和4的语法树。如果你只是写2+，在这一步就会报错。
  
  ✅语义分析———此步骤由语义分析器(Semantic Analyzer)来完成。这一步主要考虑类型声明、匹配和转换。比如你写2 * "3"在这一步就会报错。
  
  ✅中间语言生成———这一步会生成跟目标机器和运行时环境无关的三地址码(Three-address Code)，比如2 + 3会写成t1 = 2 + 3，同时也会把一些在编译期就可以确定的表达式进行优化。
  
  ✅目标代码生成———编译器根据三地址码生成依赖于目标机器的目标机器代码，也就是汇编语言。
  
  最后.i文件经过编译，得到汇编文件，后缀是.s。
  
* (3)汇编：这一步由汇编器负责，将汇编语言转换成机器可以执行的语言(完全由0和1组成).汇编文件经过汇编，变成目标文件，后缀为.o。
* (4)链接：通过调用链接器ld来将多个目标文件以及所依赖的其它库文件链接起来，最后生成可执行文件。

考虑一个.c文件中，用到了另一个.c文件中的变量或函数。在编译这个文件时，我们无法在编译期确定这个变量或函数的地址。只有在把所有目标文件链接起来以后，才能确定。链接器主要负责地址重分配、符号名称绑定和重定位。

**【扩展 17-2】静态链了解么？静态库和动态库的区别？**

**静态库**：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。

**动态库**：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。


**【扩展 17-3】内存的几大区域，各自的职能分别是什么？**

参考[【扩展 11-1】介绍下内存的几大区域？](https://github.com/baohenglin/iOS-Interview-Question/blob/master/Article/iOSInterviewQuestionsSummaryFour.md)

**【扩展 17-4】static和const有什么区别？**

static:修饰全局变量,全局变量只能在当前文件下使用。
    
const:被它修饰的变量,是只读的变量。

**【扩展 17-5】了解内联函数么？**

什么是内联函数？内联函数是C++的增强特性之一，用来降低程序的运行时间。当内联函数收到编译器的指示时，即可发生内联：编译器将使用函数的定义体来替代函数调用语句，这种替代行为发生在编译阶段而非程序运行阶段。

定义函数时，在函数的最前面以关键字“inline”声明函数，即可使函数称为内联声明函数。

**inline函数的优点**：

* 它通过避免函数调用所带来的开销来提高你程序的运行速度。
* 当函数调用发生时，它节省了变量弹栈、压栈的开销。
* 它避免了一个函数执行完返回原现场的开销。
* 通过将函数声明为内联，你可以把函数定义放在头文件内。

**inline函数的缺点**：

* 因为代码的扩展，内联函数增大了可执行程序的体积。
* C++内联函数的展开是在编译阶段，这就意味着如果你的内联函数发生了改动，那么就需要重新编译代码。
* 当你把内联函数放在头文件中时，它将会使你的头文件信息变多，不过头文件的使用者不用在意这些。

**【扩展 17-6】了解编译的过程么？分为哪几个步骤？**

同【扩展 17-1】

**【扩展 17-7】应用层、API、运行库、系统调用、操作系统内核之间的关系是什么？**

![计算机调用结构.png](https://upload-images.jianshu.io/upload_images/4164292-b2fada6ea68d14d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 最上层是应用层。不管是浏览器、游戏，还是我们使用的各种开发工具，如Xcode，VS，汇编器自身等，都属于这一范畴。
* 第二层是操作系统的运行库。我们在程序里调用系统API，比如文件读写，就是调用了第二层提供的相应服务。这种调用通过操作系统的API完成，它沟通了应用层和操作系统的运行库。这也就是为什么不管是在Mac还是Windows上编程，我们都可以调用printf()或fread()等函数。因为不同的操作系统的运行库提供了不同底层的实现，但对应用层提供的API总是一样的。
* 第三层是操作系统内核。操作系统的运行库通过系统调用(System Call)调用系统内核提供的函数。比如fread属于API，它在Linux下会调用read()这个系统调用，而在Windows下会调用ReadFile()这个系统调用。应用程序可以直接调用系统调用，但是这样一来，我们需要考虑各个操作系统下系统调用的不同，而且系统调用由于更加底层，实现起来也就更加困难。最关键的是，系统调用是通过中断来完成的，涉及到堆栈的保存与恢复，频繁的系统调用会影响性能
* 第四层是硬件层。程序无法直接访问这一层，只有操作系统的内核，通过硬件厂商提供的接口才能访问。

**【扩展 17-8】虚拟内存空间是什么，为什么要有虚拟内存空间？**

**虚拟地址空间**:是指应用程序自己认为，自己所处的地址空间。它区别于物理地址空间。后者是真实存在的，比如电脑有一根8G的内存条，物理地址空间就是0~8Gb。CPU的MMU(内存管理单元)负责把虚拟地址转换成物理地址。

**引入虚拟地址的好处:**

* 程序员不再关心真实的物理内存空间是什么样的，理论上来说(64位CPU的虚拟内存为2^64)，程序员有几乎无限大的虚拟内存空间可用，最后只要建立虚拟地址和物理地址的对应关系即可；
* 操作系统屏蔽了物理内存空间的细节，进程无法访问到操作系统禁止访问的物理地址，也不能访问到别的进程的地址空间，这大大增强了程序安全性；
* 由虚拟地址空间引申出来的分页(Paging)技术，大大提高了内存的使用效率。要想运行一个程序，不再需要把整个程序都放入内存中执行，我们只要保证将要执行的页在内存中即可，如果不存在则导致页错误。

**【扩展 17-9】静态链接和动态链接分别表示什么，大概是怎么实现的？**

**【扩展 17-10】可执行文件的结构如何？（分为哪些段）**

**【扩展 17-11】它是怎么装载进内存的，为什么要分段，分页，页错误是什么？**

**【扩展 17-12】进程的内存格局是怎样的？（堆、栈、全局/静态区，代码区，常量区）**

**【扩展 17-13】堆和栈的区别，函数调用和栈的关系？**

**【扩展 17-14】进程和线程的区别？**

**【扩展 17-15】异步和同步，串行，并发，并行的区别？**

**【扩展 17-16】多并发任务，仅多线程能加快速度么（不能，会变慢，有线程切换的开销）？**

**【扩展 17-17】多个线程之间可以共享哪些数据？**

**【扩展 17-18】进程之间如何通信？**

**【扩展 17-19】介绍几种锁，他们的用途和区别？**


## 知识点18 第三方库 & 组件化

**【扩展 18-1】介绍自己用过哪些开源库？**

Masonry 和 SnapKit，AFNetWorking，MKNetworkKit，Alamofire，Mantle，SDWebImage

JSON转Model的框架：YYModel、Mantle。

**【扩展 18-2】读过某个库的源码么？**

**【扩展 18-3】SDWebImage 下载了图片后为什么要解码？**

**【扩展 18-4】项目有没有做过组件化？或者你是否调研过？**

**【扩展 18-5】如果让你实现 NSNotificationCenter，讲一下思路**




## 知识点19 Swift

**【扩展 19-1】Swift 中 struct 和 class 的区别？**

**【扩展 19-2】Swift 是如何实现多态的？**

**【扩展 19-3】Swift 和 OC，各自的优缺点有哪些？**

**【扩展 19-4】用 Alamofire 比直接使用 URLSession，优势是什么？**


## 知识点20 开放性问题

**【扩展 20-1】哪一个项目技术点最能体现自己的技术实力？具体讲一下。**

**【扩展 20-2】你在项目中遇到的最大的问题是什么？你是怎么解决的？**

**【扩展 20-3】你是如何学习 iOS 的？**

**【扩展 20-4】和产品经理、测试产生冲突时，你是怎么解决的？**
