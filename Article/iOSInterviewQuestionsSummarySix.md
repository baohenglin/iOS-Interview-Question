## 知识点17  操作系统与编译原理

**【扩展 17-1】源代码是怎么变成可执行文件的？每一步的作用是什么？**

源代码变成可执行文件需要经过以下过程：

* (1)预编译：负责这一步工作的叫“预编译器”。它主要负责将所有的#define删除，并且展开所有的宏定义；处理所有的条件预编译指令，比如#if #ifdef #elif #else #endif等；处理#include 预编译指令，将被包含的文件插入到该预编译指令的位置；删除所有注释“//”和”/* */”；添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号；保留所有的#pragma编译器指令，因为编译器需要使用它们；最终.c文件经过预编译，变为.i文件。
* (2)编译：由编译器负责，主要又由词法分析、语法分析、语义分析、优化和生成汇编代码五个部分：

  ✅词法分析———识别源代码中的各种括号、数字、标点等。比如有(但没有)，这一步就能发现错误。
  
  ✅语法分析———这一步会通过语法分析器(Grammar Parser)会生成语法树，比如2+4就是一颗根节点为+，左右叶节点分别为2和4的语法树。如果你只是写2+，在这一步就会报错。
  
  ✅语义分析———此步骤由语义分析器(Semantic Analyzer)来完成。这一步主要考虑类型声明、匹配和转换。比如你写2 * "3"在这一步就会报错。
  
  ✅中间语言生成———这一步会生成跟目标机器和运行时环境无关的三地址码(Three-address Code)，比如2 + 3会写成t1 = 2 + 3，同时也会把一些在编译期就可以确定的表达式进行优化。
  
  ✅目标代码生成———编译器根据三地址码生成依赖于目标机器的目标机器代码，也就是汇编语言。
  
  最后.i文件经过编译，得到汇编文件，后缀是.s。
  
* (3)汇编：这一步由汇编器负责，将汇编语言转换成机器可以执行的语言(完全由0和1组成).汇编文件经过汇编，变成目标文件，后缀为.o。
* (4)链接：通过调用链接器ld来将多个目标文件以及所依赖的其它库文件链接起来，最后生成可执行文件。

考虑一个.c文件中，用到了另一个.c文件中的变量或函数。在编译这个文件时，我们无法在编译期确定这个变量或函数的地址。只有在把所有目标文件链接起来以后，才能确定。链接器主要负责地址重分配、符号名称绑定和重定位。

**【扩展 17-2】静态链了解么？静态库和动态库的区别？**

**静态库**：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。

**动态库**：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。


**【扩展 17-3】内存的几大区域，各自的职能分别是什么？**

参考[【扩展 11-1】介绍下内存的几大区域？](https://github.com/baohenglin/iOS-Interview-Question/blob/master/Article/iOSInterviewQuestionsSummaryFour.md)

**【扩展 17-4】static和const有什么区别？**

static:修饰全局变量,全局变量只能在当前文件下使用。
    
const:被它修饰的变量,是只读的变量。

**【扩展 17-5】了解内联函数么？**

什么是内联函数？内联函数是C++的增强特性之一，用来降低程序的运行时间。当内联函数收到编译器的指示时，即可发生内联：编译器将使用函数的定义体来替代函数调用语句，这种替代行为发生在编译阶段而非程序运行阶段。

定义函数时，在函数的最前面以关键字“inline”声明函数，即可使函数称为内联声明函数。

**inline函数的优点**：

* 它通过避免函数调用所带来的开销来提高你程序的运行速度。
* 当函数调用发生时，它节省了变量弹栈、压栈的开销。
* 它避免了一个函数执行完返回原现场的开销。
* 通过将函数声明为内联，你可以把函数定义放在头文件内。

**inline函数的缺点**：

* 因为代码的扩展，内联函数增大了可执行程序的体积。
* C++内联函数的展开是在编译阶段，这就意味着如果你的内联函数发生了改动，那么就需要重新编译代码。
* 当你把内联函数放在头文件中时，它将会使你的头文件信息变多，不过头文件的使用者不用在意这些。

**【扩展 17-6】了解编译的过程么？分为哪几个步骤？**

同【扩展 17-1】

**【扩展 17-7】应用层、API、运行库、系统调用、操作系统内核之间的关系是什么？**

![计算机调用结构.png](https://upload-images.jianshu.io/upload_images/4164292-b2fada6ea68d14d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 最上层是应用层。不管是浏览器、游戏，还是我们使用的各种开发工具，如Xcode，VS，汇编器自身等，都属于这一范畴。
* 第二层是操作系统的运行库。我们在程序里调用系统API，比如文件读写，就是调用了第二层提供的相应服务。这种调用通过操作系统的API完成，它沟通了应用层和操作系统的运行库。这也就是为什么不管是在Mac还是Windows上编程，我们都可以调用printf()或fread()等函数。因为不同的操作系统的运行库提供了不同底层的实现，但对应用层提供的API总是一样的。
* 第三层是操作系统内核。操作系统的运行库通过系统调用(System Call)调用系统内核提供的函数。比如fread属于API，它在Linux下会调用read()这个系统调用，而在Windows下会调用ReadFile()这个系统调用。应用程序可以直接调用系统调用，但是这样一来，我们需要考虑各个操作系统下系统调用的不同，而且系统调用由于更加底层，实现起来也就更加困难。最关键的是，系统调用是通过中断来完成的，涉及到堆栈的保存与恢复，频繁的系统调用会影响性能
* 第四层是硬件层。程序无法直接访问这一层，只有操作系统的内核，通过硬件厂商提供的接口才能访问。

**【扩展 17-8】虚拟内存空间是什么，为什么要有虚拟内存空间？**

**虚拟地址空间**:是指应用程序自己认为，自己所处的地址空间。它区别于物理地址空间。后者是真实存在的，比如电脑有一根8G的内存条，物理地址空间就是0~8Gb。CPU的MMU(内存管理单元)负责把虚拟地址转换成物理地址。

**引入虚拟地址的好处:**

* 程序员不再关心真实的物理内存空间是什么样的，理论上来说(64位CPU的虚拟内存为2^64)，程序员有几乎无限大的虚拟内存空间可用，最后只要建立虚拟地址和物理地址的对应关系即可；
* 操作系统屏蔽了物理内存空间的细节，进程无法访问到操作系统禁止访问的物理地址，也不能访问到别的进程的地址空间，这大大增强了程序安全性；
* 由虚拟地址空间引申出来的分页(Paging)技术，大大提高了内存的使用效率。要想运行一个程序，不再需要把整个程序都放入内存中执行，我们只要保证将要执行的页在内存中即可，如果不存在则导致页错误。

**【扩展 17-9】静态链接和动态链接分别表示什么，大概是怎么实现的？**

[静态链接和动态链接](https://www.jianshu.com/p/b2ff3117faf1)

**静态链接**:是指链接阶段将多个目标文件和相关的静态库组合在一起形成一个可执行文件。静态链接包括两个大部分：一是空间和地址的分配；二是符号解析和重定位。

* 空间和地址分配：

扫描所有的输入目标文件，获得他们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这样，连接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。

* 符号解析与重定位：

符号解析:解析符号就是将每个符号引用与它输入的可重定位目标文件中的符号表中的一个确定的符号定义联系起来。若找不到，则出现编译时错误。

重定位：根据目标文件的重定位入口所修正的指令寻址方式，进行正确的寻址。

**动态链接**：是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。

动态链接基本分为三步：先是启动动态链接器本身，然后装载所有需要的共享对象，最后重定位和初始化。

* **启动动态链接器**:动态链接器有其自身的特殊性：首先，动态链接器本身不可以依赖其他任何共享对象（人为控制）；其次动态链接器本身所需要的全局和静态变量的重定位工作由它自身完成（自举代码）。
我们知道，在Linux下，动态链接器ld.so实际上也是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间中。操作系统在加载完动态链接器之后，就将控制权交给动态链接器。动态链接器入口地址即是自举代码的入口。动态链接器启动后，它的自举代码即开始执行。自举代码首先会找到它自己的GOT(全局偏移表，记录每个段的偏移位置）。而GOT的第一个入口保存的就是“.dynamic”段的偏移地址，由此找到动态链接器本身的“.dynamic”段。通过“.dynamic”段中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，然后将它们重定位。完成自举后，就可以自由地调用各种函数和全局变量。
* **装载共享对象**：完成自举后，动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表当中，称之为“全局符号表”。然后链接器开始寻找可执行文件所依赖的共享对象：从“.dynamic”段中找到DT_NEEDED类型，它所指出的就是可执行文件所依赖的共享对象。由此，动态链接器可以列出可执行文件所依赖的所有共享对象，并将这些共享对象的名字放入到一个装载集合中。然后链接器开始从集合中取出所需要的共享对象的名字，找到相应的文件后打开该文件，读取相应的ELF文件头和“.dynamic”，然后将它相应的代码段和数据段映射到进程空间中。如果这个ELF共享对象还依赖于其他共享对象，那么将依赖的共享对象的名字放到装载集合中。如此循环，直到所有依赖的共享对象都被装载完成为止。
* **重定位和初始化**:当上述两步完成以后，动态链接器开始重新遍历可执行文件和每个共享对象的重定位表，将表中每个需要重定位的位置进行修正，原理同前。
重定位完成以后，如果某个共享对象有“.init”段，那么动态链接器会执行“.init”段中的代码，用以实现共享对象特有的初始化过程。


**【扩展 17-10】可执行文件的结构如何？（分为哪些段）**

可执行文件结构如下图所示：

![可执行文件结构.png](https://upload-images.jianshu.io/upload_images/4164292-2247620fb812221c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

【注意】可执行文件中有多个Segment,从装载的角度，我们目前只关心两个“Load”类型的Segment,因为只有它是需要被映射的，其他的诸如“NOTE”、“TLS”、“GNU_STACK”都是在装载时起辅助作用的。

* ELF Header: 用来描述整个文件的组织，文件类型，机器类型，程序入口地址。
* Program Header Table:描述了ELF文件该如何被操作系统映射到进程的虚拟空间。
* Segment 1: 目标文件中可读可执行的section的集合，如.text，.init等
* Segment 2: 目标文件中可读可写的section的集合。如.data，.bss等
* Section Header Table optional:ELF Header中描述的节区头描述表的起始位置，文件包含了多少个节，这个数组就有多少个成员，每个成员描述了对应一个节区的名字，偏移地址，虚拟地址，可读写信息等。

**【扩展 17-11】它是怎么装载进内存的，为什么要分段，分页，页错误是什么？**

[参考第6题](https://www.jianshu.com/p/b2ff3117faf1)

**【扩展 17-12】进程的内存格局是怎样的？（堆、栈、全局/静态区，代码区，常量区）**

* 代码段(Text segment): 用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存种的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。
* 数据段(Data segment): 存放已经初始化过的静态变量和全局变量，这个内存区域不是匿名的。它映射了一部分的程序二进制镜像，也就是源代码中指定了初始值的静态变量。所以，如果你写static int cntWorkerBees = 10，则cntWorkerBees的内容就保存在数据段中了，而且初始值为10。
* BSS 段(): 保存的是未被初始化的静态变量和全局变量，它们的值不是直接在程序的源代码中设定的。BSS内存区域是匿名的：它不映射到任何文件。如果你写static int cntActiveUsers，则cntActiveUsers的内容就会保存在BSS中。
* 堆(heap)：用于运行时内存分配，一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统释放。该区存放由new、malloc产生的动态数据。
* 内存映射段(Memory Mapping Segment)：内核将文件的内容直接映射到内存。内存映射是一种方便高效的文件I/O 方式，所以它被用于加载动态库。创建一个不对应于任何文件的匿名内存映射也是可能的，此方法用于存放程序的数据。在Linux中，如果你通过malloc请求一大块内存，C 运行库将会创建这样一个匿名映射而不是使用堆内存。‘大块’意味着比MMAP_THRESHOLD还大，缺省是 128KB，可以通过mallopt调整
* 栈(stack)：用于存储局部变量和函数参数,由编译器自动分配和释放。调用一个方法或函数会将一个新的栈桢（stack frame）压入栈中。栈桢在函数返回时被清理。另外，持续的重用栈空间有助于使活跃的栈内存保持在CPU缓存中，从而加速访问。进程中的每一个线程都有属于自己的栈。
* 内核态内存空间 (Kernel space)： 供内核使用，其大小一般比较固定，但 32 位系统和64 位系统的值不一样。

**【扩展 17-13】堆和栈的区别，函数调用和栈的关系？**

**堆和栈的区别：**

* (1)申请方式：栈由系统自动分配，而堆需要程序员自己申请，并指明大小。
* (2)申请后系统的响应：

栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出；

堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。
* (3)申请大小限制： 

栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。

堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小
受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

* (4)申请效率比较

栈: 由系统自动分配，速度较快。但程序员是无法控制的。

堆: 是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

* (5)存储内容

栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可 执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

* (6)存取效率:栈快堆慢。 


**【扩展 17-14】进程和线程的区别？**

进程:具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

线程:进程的一个执行单元,是CPU调度和分派的基本单位,也被称为称为轻量级进程。

**联系：**

* 一个进程可以由多个线程或单个线程组成；
* 线程与同属一个进程的其他的线程共享进程所拥有的全部资源；
* 二者均可并发执行。

**区别：**

* 地址空间: 进程拥有独立的地址空间； 线程共享本进程的地址空间。
* 资源拥有: 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等。
* 独立性: 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
* 系统开销: 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销也远大于线程切换的开销。
* 执行过程: 每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

**【扩展 17-15】异步和同步，串行，并发，并行的区别？**

**【扩展 17-16】多并发任务，仅多线程能加快速度么（不能，会变慢，有线程切换的开销）？**

**【扩展 17-17】多个线程之间可以共享哪些数据？**

**【扩展 17-18】进程之间如何通信？**

**【扩展 17-19】介绍几种锁，他们的用途和区别？**


## 知识点18 第三方库 & 组件化

**【扩展 18-1】介绍自己用过哪些开源库？**

Masonry 和 SnapKit，AFNetWorking，MKNetworkKit，Alamofire，Mantle，SDWebImage

JSON转Model的框架：YYModel、Mantle。

**【扩展 18-2】读过某个库的源码么？**

**【扩展 18-3】SDWebImage 下载了图片后为什么要解码？**

**【扩展 18-4】项目有没有做过组件化？或者你是否调研过？**

**【扩展 18-5】如果让你实现 NSNotificationCenter，讲一下思路**




## 知识点19 Swift

**【扩展 19-1】Swift 中 struct 和 class 的区别？**

**【扩展 19-2】Swift 是如何实现多态的？**

**【扩展 19-3】Swift 和 OC，各自的优缺点有哪些？**

**【扩展 19-4】用 Alamofire 比直接使用 URLSession，优势是什么？**


## 知识点20 开放性问题

**【扩展 20-1】哪一个项目技术点最能体现自己的技术实力？具体讲一下。**

**【扩展 20-2】你在项目中遇到的最大的问题是什么？你是怎么解决的？**

**【扩展 20-3】你是如何学习 iOS 的？**

**【扩展 20-4】和产品经理、测试产生冲突时，你是怎么解决的？**
